+++
title = 'חמש תובנות מעשיות להגשת מודלים עם Triton Inference Server'
date = 2025-12-15T10:00:00+02:00
draft = false
tags = ['machine-learning', 'mlops', 'inference', 'triton']
+++

Triton Inference Server הפך לבחירה פופולרית להגשת מודלים בסביבת פרודקשן, ומסיבה טובה: הוא מהיר, גמיש וחזק. עם זאת, שימוש אפקטיבי ב‑Triton דורש להבין איפה הוא מצטיין — ואיפה הוא ממש לא. הפוסט הזה אוסף חמש תובנות מעשיות מהפעלת Triton בפרודקשן שהלוואי והייתי מפנים מוקדם יותר.

## בחרו את שכבת ההגשה הנכונה

לא כל המודלים שייכים ל‑Triton. **השתמשו ב‑vLLM עבור מודלים גנרטיביים; השתמשו ב‑Triton עבור עומסי היסק מסורתיים יותר.**

LLMs נמצאים בכל מקום כרגע, ו‑Triton מציע אינטגרציות גם עם TensorRT-LLM וגם עם vLLM. במבט ראשון זה גורם ל‑Triton להיראות כמו one-stop shop להגשת כל דבר, ממסווגי תמונות ועד מודלי שפה גדולים.

בפועל, גיליתי ש‑Triton מוסיף מעט מאוד מעל פריסה “גולמית” של vLLM. זו לא ביקורת על Triton — זו פשוט השתקפות של עד כמה עומסים גנרטיביים שונים מהיסק קלאסי. רבות מהיכולות הטובות ביותר של Triton פשוט לא מתאימות בצורה נקייה לאופן שבו מגישים LLMs.

כמה דוגמאות קונקרטיות מבהירות זאת:

- **אצווה דינמית → אצווה רציפה**
  ה‑dynamic batcher של Triton ממתין לזמן קצר כדי לקבץ בקשות שלמות ואז מבצע אותן יחד. זה עובד מצוין עבור היסק עם צורות קלט קבועות. הגשה של LLMs, לעומת זאת, מרוויחה מ‑continuous batching, שבו בקשות חדשות מוכנסות לתוך אצווה פעילה בעוד אחרות מסיימות לייצר טוקנים. אמנם זה אפשרי טכנית דרך ה‑vLLM backend של Triton, אבל התפעול אינו פשוט ואינו ברור מאליו.

{{< img src="dynamic-vs-continuous-batching.png" alt="אצווה דינמית מול אצווה רציפה" class="article-image" resize="1200x" >}}

- **אריזת מודלים → שארדינג של מודלים**
  Triton מקל על אריזת כמה מודלים על GPU יחיד כדי לשפר ניצול. LLMs כמעט אף פעם לא מתאימים למודל הזה. אפילו מודלים צנועים נוטים לצרוך GPU שלם, וגדולים יותר דורשים שארדינג על פני GPUs או אפילו נודים. Triton לא מונע זאת, אבל גם לא ממש עוזר באופן משמעותי.

{{< img src="model-sharding-vs-packing.png" alt="שארדינג של מודלים מול אריזת מודלים" class="article-image" resize="1200x" >}}

- **מטמון בקשות → מטמון פרפיקס**
  ה‑cache המובנה של Triton עובד באמצעות שמירת זוגות בקשה–תגובה, דבר שהוא יעיל מאוד עבור עומסים דטרמיניסטיים. מודלים גנרטיביים, במקום זאת, מרוויחים ממטמון של מצב ביניים, כגון KV caches שממופתחים לפי פרפיקסים משותפים של פרומפט. זו בעיה שונה מהותית, כזו שמערכות הגשה “ילידיות LLM” מטפלות בה בצורה טבעית בהרבה.

בקיצור, בעקביות מצאתי שזה פשוט בהרבה לפרוס vLLM ישירות ולקבל מיד יתרונות של אצווה רציפה, שארדינג ומטמון פרפיקס, מאשר להוסיף שכבה של Triton מעל ולריב עם קונפיגורציה כדי להשיג התנהגות דומה.

## הגנו על לטנטיות באמצעות timeouts בצד השרת

אצווה דינמית היא יכולת הדגל של Triton. באמצעות אגירה של בקשות לחלון קצר שניתן להגדרה והרצה שלהן כאצווה, Triton משפר ניצול חומרה ומפחית כמות גדולה של מורכבות בצד הלקוח.

עם זאת, יש כאן מוקש חשוב: כברירת מחדל, Triton לא יפנה (evict) בקשות שממתינות בתור.

בעומס, לגמרי אפשרי ש‑Triton יצבור תור אחורי בזמן שלקוחות יגיעו ל‑timeout וימשיכו הלאה. אם `max_queue_delay_microseconds` לא מוגדר, אותן בקשות שננטשו יכולות להישאר בתור ובסופו של דבר לרוץ, לצרוך משאבים בזמן שבקשות חדשות יותר ממתינות לתורן.

התוצאה מעוותת אבל נפוצה:

- Triton מבזבז זמן על עיבוד בקשות שהלקוח כבר ויתר עליהן.
- הלטנטיות עולה בזמן שהתור מתרוקן מעבודה מיושנת.

הבעיה הזו חריפה במיוחד כשמשתמשים ב‑Python backend. בעוד שחלק מה‑backends הנייטיביים יכולים לזהות ביטול מצד הלקוח, ה‑Python backend משאיר את האחריות הזו ברובה לקוד המשתמש. ברגע שבקשה מגיעה לשיטת `execute()` שלכם, היא לרוב תרוץ עד סיום אלא אם תבדקו במפורש אם בוטלה.

אם אכפת לכם מלטנטיות — וכמעט בוודאות אכפת לכם — timeouts לתור בצד השרת אינם אופציונליים.

## שמרו על ספריות לקוח מינימליות

Triton דורש שלקוחות ידעו שמות מודלים, שמות טנסורים, צורות וסוגי נתונים. לחשוף את זה ישירות למפתחים אפליקטיביים זה לא נעים, ולכן לרוב משתלם לספק מעטפת לקוח קטנה.

הבעיה מתחילה כשהמעטפת הזאת מפתחת שאיפות.

ראיתי (וגם בניתי) ספריות לקוח שמנסות לעזור באמצעות הוספת retries, backoff או תכונות עמידות אחרות. בפועל, זה לעיתים קרובות מתהפך לרעה. ניסיון חוזר לבקשות שנכשלו בגלל עומס או קלט לא תקין יכול להגביר תעבורה בדיוק כשהמערכת כבר מתקשה, ולהפוך האטה זמנית ל‑denial-of-service שנגרם מעצמנו.

אין הכוונה שלא להשתמש ב‑retries, אלא שלא להפוך אותם לבלתי נראים, ולאפשר לקוראים לזהות ולהיות מזוהים כאשר יש צורך לחזור ולבחון את לוגיקת ה‑retry.

ההמלצה שלי פשוטה: שמרו על ספריות הלקוח משעממות. תנו להן לטפל בבניית הבקשה ותו לא. מימשו retries וטיפול בשגיאות בנקודת הקריאה, שם לאפליקציה יש את ההקשר ואת יכולות התצפית הנחוצות כדי לעשות את הדבר הנכון.

## נצלו את המטמון המובנה של Triton

מטמון הבקשה–תגובה של Triton קל לפספס, אבל הוא יכול להיות אפקטיבי באופן מפתיע, במיוחד בסביבות ענן. מופעי GPU מגיעים לעיתים קרובות עם הרבה יותר זיכרון מערכת ממה שבאמת מנוצל, והקצאה של עוד כמה ג׳יגה-בייט למטמון יכולה לחסוך ל‑GPU עבודה מיותרת משמעותית.

זו לא המלצה גורפת — הרבה עומסים לא ירוויחו מזה — אבל בהחלט שווה להתנסות. מעקב אחר שיעורי פגיעת מטמון (cache hit rates) לצד עומק התור יכול לומר מהר מאוד אם המטמון עוזר והאם לקוח מסוים מייצר תעבורה כפולה מיותרת.

## העדיפו ThreadPoolExecutor לפרלליות בצד הלקוח

בצד הלקוח, מצאתי שהדרך הפשוטה ביותר להוציא בקשות היסק במקביל היא גם הטובה ביותר: להשתמש ב‑thread pool.

ב‑CPython, I/O של sockets משחרר את ה‑GIL. מכיוון שלקוח ה‑HTTP של Triton הוא בעיקר I/O-bound, זה הופך את `ThreadPoolExecutor` לבחירה יעילה וישירה:

```python
def infer(inputs):
    return model_client.infer(inputs=inputs)

with ThreadPoolExecutor(max_workers=8) as pool:
    results = list(pool.map(infer, batch_of_requests))
```

לגישה הזו יש כמה תכונות נחמדות:

1. הלקוח לא צריך לממש לוגיקת אצווה.
2. ה‑dynamic batcher של Triton יכול לאגד בקשות בין threads ואפילו בין לקוחות.
3. המקביליות מוגבלת באופן טבעי, ומספקת סוג של backpressure.

כל עבודה ב‑Python בתוך `infer` נשארת מסורבלת (serialized), ומה שמסתבר שהוא פיצ׳ר ולא באג: זה מונע מהלקוח להציף את השרת בעוד שהוא עדיין מאפשר I/O מקבילי יעיל.

## סיכום

Triton היא מערכת הגשה חזקה, אבל היא גם דעתנית. היא עובדת הכי טוב כשהאבסטרקציות שלה מתיישרות עם העומס שאתם מנסים להגיש.

עבור עומסי היסק קלאסיים, ה‑batching, ה‑scheduling וה‑caching של Triton הם מהטובים שיש. עבור LLMs ומודלים גנרטיביים אחרים, מערכות ייעודיות כמו vLLM לרוב מתאימות יותר. הבנה של ההבחנה הזו — וקונפיגורציה “הגנתית” של Triton כשכן משתמשים בו — עוזרת מאוד בבניית מערכות היסק אמינות ובעלות לטנטיות נמוכה.
